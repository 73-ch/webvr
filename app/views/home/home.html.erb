<script id="vs" type="x-shader/x-vertex">
  attribute vec3 position;
  attribute vec4 color;
  uniform mat4 mvpMatrix;
  varying vec4 vColor;
  void main(){
    gl_Position = mvpMatrix * vec4(position, 1.0);
    vColor = color;
  }
</script>
<script id="fs" type="x-shader/x-fragment">
  precision mediump float;
  varying vec4 vColor;
  void main(){
    gl_FragColor = vColor;
  }
</script>
<script id="lvs" type="x-shader/x-vertex">
  attribute vec3 position;
  attribute vec4 color;
  uniform mat4 mvpMatrix;
  varying vec4 vColor;
  void main(){
    float distance = distance(vec3(0.0, 0.0, 0.0), position) / 10.0;
    gl_Position = mvpMatrix * vec4(position, 1.0);
    vColor = vec4(color.r / distance, color.g / distance, color.b / distance, color.a);
  }
</script>
<script id="lfs" type="x-shader/x-fragment">
  precision mediump float;
  varying vec4 vColor;
  void main(){
    gl_FragColor = vColor;
  }
</script>
</head>
<body>
  <div id="nav">
    <p>右のURLをスマートフォンで開いてください http://dry-falls-25691.herokuapp.com/controller/<%= @channel %></p>
  </div>
  <canvas id="canvas"></canvas>
</body>
<script>
var c;
var d_motion;
var interval;
var z = 20.0;
var q = new qtnIV();
var qt_a = q.identity(q.create());
var qt_b = q.identity(q.create());
var qt_g = q.identity(q.create());
var qt = q.identity(q.create());
var alpha = 0,
    beta = 0,
    gamma = 0;
var d_motion;
var device;
var aig;
var acc;
var vrDisplay = null;
var nav = document.getElementById('nav');
var reset = document.getElementById('reset');

function clicked(){
  alpha = 0;
  beta = 0;
  gamma = 0;
}


window.onload = function(){
  var getDevice = (function(){
    var ua = navigator.userAgent;
    // if(ua.indexOf('iPhone') <= 0 && ua.indexOf('iPod') <= 0 && ua.indexOf('Android') <= 0 || ua.indexOf('Mobile') <= 0){
      var dispatcher = new WebSocketRails("dry-falls-25691.herokuapp.com/websocket");
      var channel = dispatcher.subscribe("<%= @channel %>");
      console.log(channel);

      c = document.getElementById('canvas');
      var gl = c.getContext('webgl', {antialias: !VRSamplesUtil.isMobile()});
      var stats = new WGLUStats(gl);
      if(!gl){
        alert('webgl not supported!');
        return;
      }
      if (navigator.getVRDisplays) {
        navigator.getVRDisplays().then(function (displays) {
          // Use the first display in the array if one is available. If multiple
          // displays are present you may want to present the user with a way to
          // select which display they wish to use.
          if (displays.length > 0) {
            vrDisplay = displays[0];

            // Being able to re-center your view is a useful thing in VR. It's
            // good practice to provide your users with a simple way to do so.
            VRSamplesUtil.addButton("Reset Pose", "R", null, function () { vrDisplay.resetPose(); });
          } else {
            VRSamplesUtil.addInfo("WebVR supported, but no VRDisplays found.", 3000);
          }
        });
      } else if (navigator.getVRDevices) {
        VRSamplesUtil.addError("Your browser supports WebVR but not the latest version. See <a href='http://webvr.info'>webvr.info</a> for more info.");
      } else {
        VRSamplesUtil.addError("Your browser does not support WebVR. See <a href='http://webvr.info'>webvr.info</a> for assistance.");
      }
      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      gl.clearDepth(1.0);
      gl.enable(gl.BLEND);
      gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE);

      var vertexSource = document.getElementById('vs').textContent,
          fragmentSource = document.getElementById('fs').textContent,
          programs = shaderProgram(vertexSource, fragmentSource);
      var attLocation = [];
      attLocation[0] = gl.getAttribLocation(programs, 'position');
      attLocation[1] = gl.getAttribLocation(programs, 'color');
      var attStride = [];
      attStride[0] = 3;
      attStride[1] = 4;

      var lineVertexSource = document.getElementById('lvs').textContent,
          lineFragmentSource = document.getElementById('lfs').textContent,
          lPrograms = shaderProgram(lineVertexSource, lineFragmentSource);
      var lAttLocation = [];
      lAttLocation[0] = gl.getAttribLocation(lPrograms, 'position');
      lAttLocation[1] = gl.getAttribLocation(lPrograms, 'color');
      var lAttStride = [];
      lAttStride[0] = 3;
      lAttStride[1] = 4;

      var linePostion = [0.0, 0.0, 0.0,
                         0.0, 0.0, -1.5];
      var lineColor = [0.0, 0.0, 1.0, 1.0,
                       0.0, 0.0, 1.0, 1.0];
      var linePositionBuffer = generateVBO(linePostion),
          lineColorBuffer = generateVBO(lineColor),
          lineVBOList = [linePositionBuffer, lineColorBuffer];


      var cubeSide = 10;
      var cubeData = cubeLattice(cubeSide, [0.3, 1.0, 1.0, 0.3], 6),
          vPositionBuffer = generateVBO(cubeData.p),
          vColorBuffer = generateVBO(cubeData.c),
          boxVboList = [vPositionBuffer, vColorBuffer],
          boxIndexBuffer = generateIBO(cubeData.i);

      var junior_cube = cube(2, [0.2 ,0.2, 0.4, 0.5]),
          j_position_bugger = generateVBO(junior_cube.p),
          j_color_buffer = generateVBO(junior_cube.c),
          j_vbo_list = [j_position_bugger, j_color_buffer],
          j_index_buffer = generateIBO(junior_cube.i);


      var uniLocation = [];
      uniLocation.mvpMatrix = gl.getUniformLocation(programs, 'mvpMatrix');
      var lUniLocation = [];
      lUniLocation.mvpMatrix = gl.getUniformLocation(lPrograms, "mvpMatrix");

      var m = new matIV();
      var mMatrix = m.identity(m.create());
      var lMMatrix = m.identity(m.create());
      var vMatrix = m.identity(m.create());
      var pMatrix = m.identity(m.create());
      var vpMatrix = m.identity(m.create());
      var mvpMatrix = m.identity(m.create());
      var lMvpMatrix = m.identity(m.create());
      var qMatrix = m.identity(m.create());

      var cameraPosition = [0.0, 0.0, z],
          centerPoint = [0.0, 0.0, 0.0],
          cameraUp = [0.0, 1.0, 0.0];

      var fovy = 45;
      var near = 0.5;
      var far = 100.0;

      var count = 0,
          cameraX = 0,
          cameraY = 0,
          cameraZ = 0;

      var trans = [],
          ran,
          vel_num = [],
          box_num = 10;

      for(var i = 0; i < box_num; i++){
        trans[i] = [0, 0, 0];
        ran = Math.random() * 6 - 3;
        vel_num[i] = (ran + ran / Math.abs(ran))>>0;
      }

      render();

      function render(){
        stats.begin();
        c.height = window.innerHeight;
        c.width = window.innerWidth;
        gl.viewport(0.0, 0.0, c.width, c.height);
        var aspect = c.width / c.height;
        var radians = (count % 360) * Math.PI / 180;
        m.perspective(fovy, aspect, near, far, pMatrix);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.useProgram(programs);

        setAttribute(boxVboList, attLocation, attStride, boxIndexBuffer);

        if (vrDisplay) {
          // If a VRDisplay was found, create a matrix based on its pose.
          var pose = vrDisplay.getPose();

          // The pose and orientation may be null if the VRDisplay cannot report
          // them for some reason. In that case, use reasonable defaults:
          var orientation = pose.orientation;
          cameraPosition = pose.position;
          if (!orientation) { orientation = [0, 0, 0, 1]; }
          // if (!cameraPosition) { cameraPosition = [0, 0, 0]; }
          cameraPosition = [0.0, 0.0, 4.0];
          m.fromRotationTranslation(vMatrix, orientation, cameraPosition);
          m.inverse(vMatrix, vMatrix);
        } else {
          m.lookAt(cameraPosition, centerPoint, cameraUp, vMatrix);
        }

        // q.rotate(alpha, [1.0, 0.0, 0.0], qt_a);
        // q.rotate(beta, [0.0, 0.0, 1.0], qt_b);
        // q.rotate(gamma, [0.0, 1.0, 0.0], qt_g);
        // q.multiply(qt_a, qt_b, qt);
        // q.multiply(qt, qt_g, qt);
        // q.toMatIV(qt, qMatrix);
        m.identity(mMatrix);
        m.multiply(pMatrix, vMatrix, vpMatrix);
        // m.multiply(mMatrix, qMatrix, mMatrix);
        m.multiply(vpMatrix, mMatrix, mvpMatrix);


        gl.uniformMatrix4fv(uniLocation.mvpMatrix, false, mvpMatrix);
        gl.lineWidth(1.0);

        gl.drawElements(gl.LINES, cubeData.i.length, gl.UNSIGNED_SHORT, 0);

        setAttribute(j_vbo_list, attLocation, attStride, j_index_buffer);

        for(var i = 0; i < box_num; i++){
          if(count % 50 == 0){
            for (var g = 0; g < 3; g++) {
              trans[i][g] = Math.round(trans[i][g]);
            };
            ran = Math.random() * 6 - 3;
            num = (ran + ran / Math.abs(ran))>>0;
            if(Math.abs(trans[i][Math.abs(num) - 1] + 2.0 * num / Math.abs(num)) <= 4){
              vel_num[i] = num;
            }else{
              vel_num[i] = 0.0;
            }
          }

          if(vel_num[i] != 0.0){
            trans[i][Math.abs(vel_num[i]) - 1] += vel_num[i] / Math.abs(vel_num[i]) * 0.04;
          };

          if(Math.floor(count % 25) != Math.floor(Math.random() * 10)) {
            m.identity(mMatrix);
            m.multiply(mMatrix, qMatrix, mMatrix);
            m.translate(mMatrix, trans[i], mMatrix);
            m.multiply(vpMatrix, mMatrix, mvpMatrix);
            gl.uniformMatrix4fv(uniLocation.mvpMatrix, false, mvpMatrix);
            gl.drawElements(gl.TRIANGLES, junior_cube.i.length, gl.UNSIGNED_SHORT, 0);
          };
        }

        gl.useProgram(lPrograms);
        gl.lineWidth(7.0);
        setAttribute(lineVBOList, lAttLocation, lAttStride, false);
        m.identity(lMMatrix);
        m.rotate(lMMatrix, alpha, [1.0, 0.0, 0.0], lMMatrix);
        m.rotate(lMMatrix, beta, [0.0, 1.0, 0.0], lMMatrix);
        m.rotate(lMMatrix, gamma, [0.0, 0.0, 1.0], lMMatrix);
        m.translate(lMMatrix, [0.2, 0.0, -0.5], lMMatrix);
        m.identity(vMatrix);
        m.multiply(pMatrix, vMatrix, vpMatrix);
        m.multiply(vpMatrix, lMMatrix, lMvpMatrix);
        gl.uniformMatrix4fv(lUniLocation.mvpMatrix, false, lMvpMatrix);
        gl.drawArrays(gl.LINES, 0, 2);

        stats.end();

        gl.flush();
        requestAnimationFrame(render);

        count++;
      };

      channel.bind("send", function(data) {
        if (data.reset){
          alpha = 0;
          beta = 0;
          gamma = 0;
        }else{
          nav.style.display = "none";
          var inter = data.i,
              rotation_rate = data.d;
          alpha += data.d.alpha * inter * Math.PI / 180;
          beta += data.d.gamma * inter * Math.PI / 180;
          gamma += data.d.beta * inter * Math.PI / 180;
        };
      });

      function shaderProgram(vertexSource, fragmentSource){
        var vertexShader = gl.createShader(gl.VERTEX_SHADER);
        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(vertexShader, vertexSource);
        gl.compileShader(vertexShader);
        if(!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)){
          alert(gl.getShaderInfoLog(vertexShader) + "in vertexShader");
          return null;
        }
        gl.shaderSource(fragmentShader, fragmentSource);
        gl.compileShader(fragmentShader);
        if(!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)){
          alert(gl.getShaderInfoLog(fragmentShader) + "in fragmentShader");
          return null;
        }
        var program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if(!gl.getProgramParameter(program, gl.LINK_STATUS)){
          alert(gl.getProgramInfoLog(program));
          return null;
        }
        gl.useProgram(program);
        return program;
      }

      function generateVBO(data){
        var vbo = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        return vbo;
      }

      function generateIBO(data){
        var ibo = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Int16Array(data), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        return ibo;
      }

      function setAttribute(vbo, attL, attS, ibo){
        for(var i in vbo){
          gl.bindBuffer(gl.ARRAY_BUFFER, vbo[i]);
          gl.enableVertexAttribArray(attL[i]);
          gl.vertexAttribPointer(attL[i], attS[i], gl.FLOAT, false, 0, 0);
        }
        if(ibo){
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
        }
      }
    // }else{
    //   alert("This devise is not supported")
    // }
  })();
};


</script>